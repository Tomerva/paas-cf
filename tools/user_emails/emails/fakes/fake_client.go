// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"net/url"
	"sync"

	"github.com/alphagov/paas/tools/user_emails/emails"
	cfclient "github.com/cloudfoundry-community/go-cfclient"
)

type FakeClient struct {
	ListOrgAuditorsStub        func(string) ([]cfclient.User, error)
	listOrgAuditorsMutex       sync.RWMutex
	listOrgAuditorsArgsForCall []struct {
		arg1 string
	}
	listOrgAuditorsReturns struct {
		result1 []cfclient.User
		result2 error
	}
	listOrgAuditorsReturnsOnCall map[int]struct {
		result1 []cfclient.User
		result2 error
	}
	ListOrgManagersStub        func(string) ([]cfclient.User, error)
	listOrgManagersMutex       sync.RWMutex
	listOrgManagersArgsForCall []struct {
		arg1 string
	}
	listOrgManagersReturns struct {
		result1 []cfclient.User
		result2 error
	}
	listOrgManagersReturnsOnCall map[int]struct {
		result1 []cfclient.User
		result2 error
	}
	ListOrgUsersStub        func(string) ([]cfclient.User, error)
	listOrgUsersMutex       sync.RWMutex
	listOrgUsersArgsForCall []struct {
		arg1 string
	}
	listOrgUsersReturns struct {
		result1 []cfclient.User
		result2 error
	}
	listOrgUsersReturnsOnCall map[int]struct {
		result1 []cfclient.User
		result2 error
	}
	ListOrgsStub        func() ([]cfclient.Org, error)
	listOrgsMutex       sync.RWMutex
	listOrgsArgsForCall []struct {
	}
	listOrgsReturns struct {
		result1 []cfclient.Org
		result2 error
	}
	listOrgsReturnsOnCall map[int]struct {
		result1 []cfclient.Org
		result2 error
	}
	ListSpaceAuditorsStub        func(string) ([]cfclient.User, error)
	listSpaceAuditorsMutex       sync.RWMutex
	listSpaceAuditorsArgsForCall []struct {
		arg1 string
	}
	listSpaceAuditorsReturns struct {
		result1 []cfclient.User
		result2 error
	}
	listSpaceAuditorsReturnsOnCall map[int]struct {
		result1 []cfclient.User
		result2 error
	}
	ListSpaceDevelopersStub        func(string) ([]cfclient.User, error)
	listSpaceDevelopersMutex       sync.RWMutex
	listSpaceDevelopersArgsForCall []struct {
		arg1 string
	}
	listSpaceDevelopersReturns struct {
		result1 []cfclient.User
		result2 error
	}
	listSpaceDevelopersReturnsOnCall map[int]struct {
		result1 []cfclient.User
		result2 error
	}
	ListSpaceManagersStub        func(string) ([]cfclient.User, error)
	listSpaceManagersMutex       sync.RWMutex
	listSpaceManagersArgsForCall []struct {
		arg1 string
	}
	listSpaceManagersReturns struct {
		result1 []cfclient.User
		result2 error
	}
	listSpaceManagersReturnsOnCall map[int]struct {
		result1 []cfclient.User
		result2 error
	}
	ListSpacesByQueryStub        func(url.Values) ([]cfclient.Space, error)
	listSpacesByQueryMutex       sync.RWMutex
	listSpacesByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listSpacesByQueryReturns struct {
		result1 []cfclient.Space
		result2 error
	}
	listSpacesByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.Space
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) ListOrgAuditors(arg1 string) ([]cfclient.User, error) {
	fake.listOrgAuditorsMutex.Lock()
	ret, specificReturn := fake.listOrgAuditorsReturnsOnCall[len(fake.listOrgAuditorsArgsForCall)]
	fake.listOrgAuditorsArgsForCall = append(fake.listOrgAuditorsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListOrgAuditors", []interface{}{arg1})
	fake.listOrgAuditorsMutex.Unlock()
	if fake.ListOrgAuditorsStub != nil {
		return fake.ListOrgAuditorsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listOrgAuditorsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOrgAuditorsCallCount() int {
	fake.listOrgAuditorsMutex.RLock()
	defer fake.listOrgAuditorsMutex.RUnlock()
	return len(fake.listOrgAuditorsArgsForCall)
}

func (fake *FakeClient) ListOrgAuditorsCalls(stub func(string) ([]cfclient.User, error)) {
	fake.listOrgAuditorsMutex.Lock()
	defer fake.listOrgAuditorsMutex.Unlock()
	fake.ListOrgAuditorsStub = stub
}

func (fake *FakeClient) ListOrgAuditorsArgsForCall(i int) string {
	fake.listOrgAuditorsMutex.RLock()
	defer fake.listOrgAuditorsMutex.RUnlock()
	argsForCall := fake.listOrgAuditorsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListOrgAuditorsReturns(result1 []cfclient.User, result2 error) {
	fake.listOrgAuditorsMutex.Lock()
	defer fake.listOrgAuditorsMutex.Unlock()
	fake.ListOrgAuditorsStub = nil
	fake.listOrgAuditorsReturns = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgAuditorsReturnsOnCall(i int, result1 []cfclient.User, result2 error) {
	fake.listOrgAuditorsMutex.Lock()
	defer fake.listOrgAuditorsMutex.Unlock()
	fake.ListOrgAuditorsStub = nil
	if fake.listOrgAuditorsReturnsOnCall == nil {
		fake.listOrgAuditorsReturnsOnCall = make(map[int]struct {
			result1 []cfclient.User
			result2 error
		})
	}
	fake.listOrgAuditorsReturnsOnCall[i] = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgManagers(arg1 string) ([]cfclient.User, error) {
	fake.listOrgManagersMutex.Lock()
	ret, specificReturn := fake.listOrgManagersReturnsOnCall[len(fake.listOrgManagersArgsForCall)]
	fake.listOrgManagersArgsForCall = append(fake.listOrgManagersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListOrgManagers", []interface{}{arg1})
	fake.listOrgManagersMutex.Unlock()
	if fake.ListOrgManagersStub != nil {
		return fake.ListOrgManagersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listOrgManagersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOrgManagersCallCount() int {
	fake.listOrgManagersMutex.RLock()
	defer fake.listOrgManagersMutex.RUnlock()
	return len(fake.listOrgManagersArgsForCall)
}

func (fake *FakeClient) ListOrgManagersCalls(stub func(string) ([]cfclient.User, error)) {
	fake.listOrgManagersMutex.Lock()
	defer fake.listOrgManagersMutex.Unlock()
	fake.ListOrgManagersStub = stub
}

func (fake *FakeClient) ListOrgManagersArgsForCall(i int) string {
	fake.listOrgManagersMutex.RLock()
	defer fake.listOrgManagersMutex.RUnlock()
	argsForCall := fake.listOrgManagersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListOrgManagersReturns(result1 []cfclient.User, result2 error) {
	fake.listOrgManagersMutex.Lock()
	defer fake.listOrgManagersMutex.Unlock()
	fake.ListOrgManagersStub = nil
	fake.listOrgManagersReturns = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgManagersReturnsOnCall(i int, result1 []cfclient.User, result2 error) {
	fake.listOrgManagersMutex.Lock()
	defer fake.listOrgManagersMutex.Unlock()
	fake.ListOrgManagersStub = nil
	if fake.listOrgManagersReturnsOnCall == nil {
		fake.listOrgManagersReturnsOnCall = make(map[int]struct {
			result1 []cfclient.User
			result2 error
		})
	}
	fake.listOrgManagersReturnsOnCall[i] = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgUsers(arg1 string) ([]cfclient.User, error) {
	fake.listOrgUsersMutex.Lock()
	ret, specificReturn := fake.listOrgUsersReturnsOnCall[len(fake.listOrgUsersArgsForCall)]
	fake.listOrgUsersArgsForCall = append(fake.listOrgUsersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListOrgUsers", []interface{}{arg1})
	fake.listOrgUsersMutex.Unlock()
	if fake.ListOrgUsersStub != nil {
		return fake.ListOrgUsersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listOrgUsersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOrgUsersCallCount() int {
	fake.listOrgUsersMutex.RLock()
	defer fake.listOrgUsersMutex.RUnlock()
	return len(fake.listOrgUsersArgsForCall)
}

func (fake *FakeClient) ListOrgUsersCalls(stub func(string) ([]cfclient.User, error)) {
	fake.listOrgUsersMutex.Lock()
	defer fake.listOrgUsersMutex.Unlock()
	fake.ListOrgUsersStub = stub
}

func (fake *FakeClient) ListOrgUsersArgsForCall(i int) string {
	fake.listOrgUsersMutex.RLock()
	defer fake.listOrgUsersMutex.RUnlock()
	argsForCall := fake.listOrgUsersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListOrgUsersReturns(result1 []cfclient.User, result2 error) {
	fake.listOrgUsersMutex.Lock()
	defer fake.listOrgUsersMutex.Unlock()
	fake.ListOrgUsersStub = nil
	fake.listOrgUsersReturns = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgUsersReturnsOnCall(i int, result1 []cfclient.User, result2 error) {
	fake.listOrgUsersMutex.Lock()
	defer fake.listOrgUsersMutex.Unlock()
	fake.ListOrgUsersStub = nil
	if fake.listOrgUsersReturnsOnCall == nil {
		fake.listOrgUsersReturnsOnCall = make(map[int]struct {
			result1 []cfclient.User
			result2 error
		})
	}
	fake.listOrgUsersReturnsOnCall[i] = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgs() ([]cfclient.Org, error) {
	fake.listOrgsMutex.Lock()
	ret, specificReturn := fake.listOrgsReturnsOnCall[len(fake.listOrgsArgsForCall)]
	fake.listOrgsArgsForCall = append(fake.listOrgsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListOrgs", []interface{}{})
	fake.listOrgsMutex.Unlock()
	if fake.ListOrgsStub != nil {
		return fake.ListOrgsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listOrgsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOrgsCallCount() int {
	fake.listOrgsMutex.RLock()
	defer fake.listOrgsMutex.RUnlock()
	return len(fake.listOrgsArgsForCall)
}

func (fake *FakeClient) ListOrgsCalls(stub func() ([]cfclient.Org, error)) {
	fake.listOrgsMutex.Lock()
	defer fake.listOrgsMutex.Unlock()
	fake.ListOrgsStub = stub
}

func (fake *FakeClient) ListOrgsReturns(result1 []cfclient.Org, result2 error) {
	fake.listOrgsMutex.Lock()
	defer fake.listOrgsMutex.Unlock()
	fake.ListOrgsStub = nil
	fake.listOrgsReturns = struct {
		result1 []cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgsReturnsOnCall(i int, result1 []cfclient.Org, result2 error) {
	fake.listOrgsMutex.Lock()
	defer fake.listOrgsMutex.Unlock()
	fake.ListOrgsStub = nil
	if fake.listOrgsReturnsOnCall == nil {
		fake.listOrgsReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Org
			result2 error
		})
	}
	fake.listOrgsReturnsOnCall[i] = struct {
		result1 []cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpaceAuditors(arg1 string) ([]cfclient.User, error) {
	fake.listSpaceAuditorsMutex.Lock()
	ret, specificReturn := fake.listSpaceAuditorsReturnsOnCall[len(fake.listSpaceAuditorsArgsForCall)]
	fake.listSpaceAuditorsArgsForCall = append(fake.listSpaceAuditorsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListSpaceAuditors", []interface{}{arg1})
	fake.listSpaceAuditorsMutex.Unlock()
	if fake.ListSpaceAuditorsStub != nil {
		return fake.ListSpaceAuditorsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSpaceAuditorsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListSpaceAuditorsCallCount() int {
	fake.listSpaceAuditorsMutex.RLock()
	defer fake.listSpaceAuditorsMutex.RUnlock()
	return len(fake.listSpaceAuditorsArgsForCall)
}

func (fake *FakeClient) ListSpaceAuditorsCalls(stub func(string) ([]cfclient.User, error)) {
	fake.listSpaceAuditorsMutex.Lock()
	defer fake.listSpaceAuditorsMutex.Unlock()
	fake.ListSpaceAuditorsStub = stub
}

func (fake *FakeClient) ListSpaceAuditorsArgsForCall(i int) string {
	fake.listSpaceAuditorsMutex.RLock()
	defer fake.listSpaceAuditorsMutex.RUnlock()
	argsForCall := fake.listSpaceAuditorsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListSpaceAuditorsReturns(result1 []cfclient.User, result2 error) {
	fake.listSpaceAuditorsMutex.Lock()
	defer fake.listSpaceAuditorsMutex.Unlock()
	fake.ListSpaceAuditorsStub = nil
	fake.listSpaceAuditorsReturns = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpaceAuditorsReturnsOnCall(i int, result1 []cfclient.User, result2 error) {
	fake.listSpaceAuditorsMutex.Lock()
	defer fake.listSpaceAuditorsMutex.Unlock()
	fake.ListSpaceAuditorsStub = nil
	if fake.listSpaceAuditorsReturnsOnCall == nil {
		fake.listSpaceAuditorsReturnsOnCall = make(map[int]struct {
			result1 []cfclient.User
			result2 error
		})
	}
	fake.listSpaceAuditorsReturnsOnCall[i] = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpaceDevelopers(arg1 string) ([]cfclient.User, error) {
	fake.listSpaceDevelopersMutex.Lock()
	ret, specificReturn := fake.listSpaceDevelopersReturnsOnCall[len(fake.listSpaceDevelopersArgsForCall)]
	fake.listSpaceDevelopersArgsForCall = append(fake.listSpaceDevelopersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListSpaceDevelopers", []interface{}{arg1})
	fake.listSpaceDevelopersMutex.Unlock()
	if fake.ListSpaceDevelopersStub != nil {
		return fake.ListSpaceDevelopersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSpaceDevelopersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListSpaceDevelopersCallCount() int {
	fake.listSpaceDevelopersMutex.RLock()
	defer fake.listSpaceDevelopersMutex.RUnlock()
	return len(fake.listSpaceDevelopersArgsForCall)
}

func (fake *FakeClient) ListSpaceDevelopersCalls(stub func(string) ([]cfclient.User, error)) {
	fake.listSpaceDevelopersMutex.Lock()
	defer fake.listSpaceDevelopersMutex.Unlock()
	fake.ListSpaceDevelopersStub = stub
}

func (fake *FakeClient) ListSpaceDevelopersArgsForCall(i int) string {
	fake.listSpaceDevelopersMutex.RLock()
	defer fake.listSpaceDevelopersMutex.RUnlock()
	argsForCall := fake.listSpaceDevelopersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListSpaceDevelopersReturns(result1 []cfclient.User, result2 error) {
	fake.listSpaceDevelopersMutex.Lock()
	defer fake.listSpaceDevelopersMutex.Unlock()
	fake.ListSpaceDevelopersStub = nil
	fake.listSpaceDevelopersReturns = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpaceDevelopersReturnsOnCall(i int, result1 []cfclient.User, result2 error) {
	fake.listSpaceDevelopersMutex.Lock()
	defer fake.listSpaceDevelopersMutex.Unlock()
	fake.ListSpaceDevelopersStub = nil
	if fake.listSpaceDevelopersReturnsOnCall == nil {
		fake.listSpaceDevelopersReturnsOnCall = make(map[int]struct {
			result1 []cfclient.User
			result2 error
		})
	}
	fake.listSpaceDevelopersReturnsOnCall[i] = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpaceManagers(arg1 string) ([]cfclient.User, error) {
	fake.listSpaceManagersMutex.Lock()
	ret, specificReturn := fake.listSpaceManagersReturnsOnCall[len(fake.listSpaceManagersArgsForCall)]
	fake.listSpaceManagersArgsForCall = append(fake.listSpaceManagersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListSpaceManagers", []interface{}{arg1})
	fake.listSpaceManagersMutex.Unlock()
	if fake.ListSpaceManagersStub != nil {
		return fake.ListSpaceManagersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSpaceManagersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListSpaceManagersCallCount() int {
	fake.listSpaceManagersMutex.RLock()
	defer fake.listSpaceManagersMutex.RUnlock()
	return len(fake.listSpaceManagersArgsForCall)
}

func (fake *FakeClient) ListSpaceManagersCalls(stub func(string) ([]cfclient.User, error)) {
	fake.listSpaceManagersMutex.Lock()
	defer fake.listSpaceManagersMutex.Unlock()
	fake.ListSpaceManagersStub = stub
}

func (fake *FakeClient) ListSpaceManagersArgsForCall(i int) string {
	fake.listSpaceManagersMutex.RLock()
	defer fake.listSpaceManagersMutex.RUnlock()
	argsForCall := fake.listSpaceManagersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListSpaceManagersReturns(result1 []cfclient.User, result2 error) {
	fake.listSpaceManagersMutex.Lock()
	defer fake.listSpaceManagersMutex.Unlock()
	fake.ListSpaceManagersStub = nil
	fake.listSpaceManagersReturns = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpaceManagersReturnsOnCall(i int, result1 []cfclient.User, result2 error) {
	fake.listSpaceManagersMutex.Lock()
	defer fake.listSpaceManagersMutex.Unlock()
	fake.ListSpaceManagersStub = nil
	if fake.listSpaceManagersReturnsOnCall == nil {
		fake.listSpaceManagersReturnsOnCall = make(map[int]struct {
			result1 []cfclient.User
			result2 error
		})
	}
	fake.listSpaceManagersReturnsOnCall[i] = struct {
		result1 []cfclient.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpacesByQuery(arg1 url.Values) ([]cfclient.Space, error) {
	fake.listSpacesByQueryMutex.Lock()
	ret, specificReturn := fake.listSpacesByQueryReturnsOnCall[len(fake.listSpacesByQueryArgsForCall)]
	fake.listSpacesByQueryArgsForCall = append(fake.listSpacesByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	fake.recordInvocation("ListSpacesByQuery", []interface{}{arg1})
	fake.listSpacesByQueryMutex.Unlock()
	if fake.ListSpacesByQueryStub != nil {
		return fake.ListSpacesByQueryStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSpacesByQueryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListSpacesByQueryCallCount() int {
	fake.listSpacesByQueryMutex.RLock()
	defer fake.listSpacesByQueryMutex.RUnlock()
	return len(fake.listSpacesByQueryArgsForCall)
}

func (fake *FakeClient) ListSpacesByQueryCalls(stub func(url.Values) ([]cfclient.Space, error)) {
	fake.listSpacesByQueryMutex.Lock()
	defer fake.listSpacesByQueryMutex.Unlock()
	fake.ListSpacesByQueryStub = stub
}

func (fake *FakeClient) ListSpacesByQueryArgsForCall(i int) url.Values {
	fake.listSpacesByQueryMutex.RLock()
	defer fake.listSpacesByQueryMutex.RUnlock()
	argsForCall := fake.listSpacesByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListSpacesByQueryReturns(result1 []cfclient.Space, result2 error) {
	fake.listSpacesByQueryMutex.Lock()
	defer fake.listSpacesByQueryMutex.Unlock()
	fake.ListSpacesByQueryStub = nil
	fake.listSpacesByQueryReturns = struct {
		result1 []cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpacesByQueryReturnsOnCall(i int, result1 []cfclient.Space, result2 error) {
	fake.listSpacesByQueryMutex.Lock()
	defer fake.listSpacesByQueryMutex.Unlock()
	fake.ListSpacesByQueryStub = nil
	if fake.listSpacesByQueryReturnsOnCall == nil {
		fake.listSpacesByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Space
			result2 error
		})
	}
	fake.listSpacesByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.listOrgAuditorsMutex.RLock()
	defer fake.listOrgAuditorsMutex.RUnlock()
	fake.listOrgManagersMutex.RLock()
	defer fake.listOrgManagersMutex.RUnlock()
	fake.listOrgUsersMutex.RLock()
	defer fake.listOrgUsersMutex.RUnlock()
	fake.listOrgsMutex.RLock()
	defer fake.listOrgsMutex.RUnlock()
	fake.listSpaceAuditorsMutex.RLock()
	defer fake.listSpaceAuditorsMutex.RUnlock()
	fake.listSpaceDevelopersMutex.RLock()
	defer fake.listSpaceDevelopersMutex.RUnlock()
	fake.listSpaceManagersMutex.RLock()
	defer fake.listSpaceManagersMutex.RUnlock()
	fake.listSpacesByQueryMutex.RLock()
	defer fake.listSpacesByQueryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ emails.Client = new(FakeClient)
